# 適用データ生成
# 元データは、Clausen,1998=2015「対応分析入門」, p.189より
tbl <- matrix( c( 395 , 2456 , 1758 , 147 , 153 , 916 , 694 , 327 , 1347)  , byrow=3  , ncol = 3)
colnames(tbl) <- c("強盗" , "詐欺", "破壊")
rownames(tbl) <- c( "オスロ" , "中部地域", "北部地域")

#分布に変換
tbl_p <-  tbl / sum(tbl)
mgn_c <- apply( tbl_p , 2, sum)#列周辺分布
mgn_r <- apply( tbl_p , 1, sum) #行周辺分布

D_clm <- diag(1/sqrt(mgn_c)) #列周辺分布の-1/2乗を対角成分とした行列
D_row <- diag(1/sqrt(mgn_r)) #行周辺分布の-1/2乗を対角成分とした行列

# SVDを適用する対象の行列をつくる。
mat_A <- D_clm %*% (tbl_p - mgn_r %o% mgn_c) %*% D_row


## SVDを適用する
svd_res <- svd( mat_A) 

#--結果--#
# ちなみに上記の解説とはuとvが逆になってるので、注意が必要（uが左, vが右）
#$d  （特異値）
#[1] 7.927067e-01 8.484083e-02 1.339025e-17
#
#$u（左特異ベクトル）
#          [,1]        [,2]      [,3]
#[1,] -0.9210524  0.02831857 0.3884076
#[2,]  0.2288391 -0.76764442 0.5986273
#[3,]  0.3151112  0.64025003 0.7005604
#$v （右特異ベクトル）
#          [,1]       [,2]      [,3]
#[1,]  0.1744326  0.6379811 0.7500356
#[2,] -0.8992856 -0.2070410 0.3852524
#[3,]  0.4010719 -0.7416968 0.5376125


## 実際に固有値を利用する方法でやってみるver
#今回は行列Aが正方行列なので計算量的にはどっちでもいいが、
#とりあえず、左特異ベクトルを求めてから変換公式で右特異ベクトルを求める形にする。

mat_B <- mat_A %*% t(mat_A) #固有値分解の対象行列を生成
evd_res <- eigen(mat_B, TRUE) #固有値分解する

sval <- sqrt(evd_res$values ) #平方根をとることで特異値をえる
u_vec <- evd_res$vectors #左特異ベクトルを得る

v_vec <-    t(mat_A) %*% u_vec %*% diag(  1/ sval)  #変換公式 v =  1/λ * A^t * u を適用
#補足： 1/λjを対角成分とする対角行列を右からかけることによってj列を1/λj倍している

### 固有値分解をアプローチによる結果 ###
#> sval
#[1] 7.927067e-01 8.484083e-02 8.575436e-09
#> u_vec
#           [,1]        [,2]       [,3]
#[1,]  0.9210524  0.02831857 -0.3884076
#[2,] -0.2288391 -0.76764442 -0.5986273
#[3,] -0.3151112  0.64025003 -0.7005604
#> v_vec
#           [,1]       [,2]          [,3]
#[1,] -0.1744326  0.6379811 -1.941982e-08
#[2,]  0.8992856 -0.2070410 -6.473275e-09
#[3,] -0.4010719 -0.7416968  2.427478e-08
 
#--この場合、二軸で分散を説明しきっているので、3個目／3列目の特異値／特異ベクトルは誤差というか無視して良い
#--2つ目までのの特異値と特異ベクトルは先ほどのsvd()関数の戻り値と完全に一致しており、求める結果が得られた
#--なおひとつめの特異ベクトルは符号が違うが、左右一緒に同一固有値に対応する特異ベクトルの符号を変えさえすれば-1をかけてもよい（正規直交基底の性質と変換公式を考えれば明らか）
